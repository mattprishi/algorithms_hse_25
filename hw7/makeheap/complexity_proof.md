# Доказательство асимптотической сложности для makeheap

## Алгоритм makeheap (Флойда)

Алгоритм преобразует произвольный массив в min-heap за линейное время O(N), используя подход "снизу вверх".

### Описание алгоритма

1. Представляем массив как полное бинарное дерево
2. Начинаем с последнего неконечного узла (индекс `n // 2 - 1`)
3. Для каждого узла выполняем операцию heapify_down, двигаясь к корню
4. heapify_down восстанавливает свойство кучи для поддерева с корнем в данном узле

### Доказательство сложности O(N)

#### Анализ высот

В полном бинарном дереве с N узлами:
- Высота дерева: h = ⌊log₂ N⌋
- Узлов на высоте k: N_k ≤ ⌈N / 2^(k+1)⌉
- Максимальное количество перемещений для узла на высоте k: k

#### Подсчет операций

Общее количество операций:

```
T(N) = Σ(k=0 to h) [количество узлов на высоте k] × [высота k]
     = Σ(k=0 to h) ⌈N / 2^(k+1)⌉ × k
     ≤ Σ(k=0 to h) (N / 2^(k+1)) × k
     = N × Σ(k=0 to h) k / 2^(k+1)
```

#### Вычисление суммы

Рассмотрим сумму:

```
S = Σ(k=0 to ∞) k / 2^(k+1)
```

Используем формулу для суммы геометрической прогрессии:

```
Σ(k=0 to ∞) k × x^k = x / (1-x)²    для |x| < 1
```

При x = 1/2:

```
Σ(k=0 to ∞) k / 2^k = (1/2) / (1 - 1/2)² = (1/2) / (1/4) = 2
```

Следовательно:

```
S = Σ(k=0 to ∞) k / 2^(k+1) = (1/2) × Σ(k=0 to ∞) k / 2^k = (1/2) × 2 = 1
```

#### Итоговая сложность

```
T(N) = N × Σ(k=0 to h) k / 2^(k+1)
     ≤ N × Σ(k=0 to ∞) k / 2^(k+1)
     = N × 1
     = O(N)
```

### Вывод

Алгоритм makeheap имеет **линейную временную сложность O(N)**, что делает его значительно эффективнее наивного подхода с последовательной вставкой элементов O(N log N).

---

## Алгоритм makeheap_n_log_n

### Описание алгоритма

1. Создаем пустую кучу
2. Последовательно вставляем каждый элемент исходного массива
3. При вставке элемента выполняем heapify_up для восстановления свойства кучи

### Доказательство сложности O(N log N)

- Вставка одного элемента в кучу размера k требует O(log k) операций (heapify_up)
- Для N элементов:
  ```
  T(N) = Σ(i=1 to N) log i
       = log(1) + log(2) + ... + log(N)
       = log(N!)
       ≈ N log N - N
       = O(N log N)
  ```

### Сравнение алгосов

| Алгоритм           | Сложность  | Подход         |
|--------------------|------------|----------------|
| makeheap_n_log_n   | O(N log N) | Сверху вниз    |
| makeheap (Floyd)   | O(N)       | Снизу вверх    |

Интуиция такая: Floyd работает быстрее, потому что большинство узлов находятся на нижних уровнях дерева, где требуется меньше операций для heapify_down.

