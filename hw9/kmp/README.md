#### Объяснение алгоритма

КМП — это эффективный алгоритм поиска подстроки (`pattern`) в тексте (`text`), ключевая особенность которого — избегание повторных проверок символов текста. Это достигается за счет предварительного анализа `pattern` и создания **префикс-функции**.

1.  **Префикс-функция (`π` или LPS array):**
    *   Для каждой позиции `i` в `pattern` вычисляется значение `π[i]` — длина самого длинного *собственного* префикса подстроки `pattern[0...i]`, который одновременно является её суффиксом.
    *   **Пример:** для `pattern = "abacaba"`, префикс-функция `π = [0, 0, 1, 0, 1, 2, 3]`. Здесь `π[6] = 3`, так как префикс `"aba"` (длина 3) совпадает с суффиксом `"aba"`.

2.  **Процесс поиска:**
    *   Два указателя движутся по тексту (`i`) и подстроке (`j`).
    *   **При совпадении `text[i] == pattern[j]`:** оба указателя сдвигаются вперед.
    *   **При несовпадении:** указатель текста `i` **не сдвигается назад**. Указатель подстроки `j` откатывается на позицию `π[j-1]`, что позволяет "умно" сдвинуть `pattern` без повторных сравнений уже проверенной части текста.

#### Оценка сложности

*   **Время выполнения: `O(N + M)`**
    *   `O(M)` на вычисление префикс-функции (один проход по `pattern`).
    *   `O(N)` на поиск в тексте (указатель по тексту `i` движется только вперед, гарантируя один проход).
    *   Итоговая сложность — **линейная**, что является главным преимуществом алгоритма.

*   **Память: `O(M)`**
    *   Требуется дополнительная память для хранения массива префикс-функции размером `M`.

**Вывод:** КМП гарантирует линейное время работы за счет умного использования структуры самой подстроки, что делает его одним из самых эффективных и надежных алгоритмов для этой задачи.