#### Объяснение алгоритма

LCS (Longest Common Subsequence) — это классическая задача на динамическое программирование для нахождения самой длинной подпоследовательности, которая встречается в заданном порядке в обеих строках. Символы не обязательно должны идти подряд.

**Пример:**
- `s1 = "AGGTAB"`
- `s2 = "GXTXAYB"`
- `LCS = "GTAB"` (длина 4)

1.  **Построение DP-таблицы:**
    *   Создается матрица `dp` размером `(len(s1)+1) x (len(s2)+1)`.
    *   Элемент `dp[i][j]` хранит **длину** наибольшей общей подпоследовательности для префиксов `s1[:i]` и `s2[:j]`.
    *   **Рекуррентное соотношение:**
        - Если `s1[i-1] == s2[j-1]`, то символы совпадают: `dp[i][j] = 1 + dp[i-1][j-1]`
        - Иначе берем максимум: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

2.  **Восстановление подпоследовательности:**
    *   После заполнения матрицы выполняется "обратный ход" от `dp[m][n]` к началу.
    *   **Если `s1[i-1] == s2[j-1]`:** этот символ входит в LCS. Добавляем его в результат и двигаемся по диагонали (`i-1`, `j-1`).
    *   **Иначе:** двигаемся в направлении большего значения: вверх (`i-1`, `j`) или влево (`i`, `j-1`).

#### Оценка сложности

*   **Время выполнения: `O(N × M)`**
    *   `N` — длина первой строки
    *   `M` — длина второй строки
    *   Требуется заполнить всю матрицу размером `(N+1) × (M+1)`
    *   Восстановление подпоследовательности занимает `O(N + M)`

*   **Память: `O(N × M)`**
    *   Требуется хранить DP-таблицу размером `(N+1) × (M+1)`
    *   **Оптимизация:** если нужна только длина LCS (без восстановления), можно использовать `O(min(N, M))` памяти, храня только две строки матрицы

**Вывод:** LCS — это фундаментальный алгоритм, применяемый в биоинформатике (сравнение ДНК последовательностей), системах контроля версий (diff), проверке плагиата и многих других областях.

