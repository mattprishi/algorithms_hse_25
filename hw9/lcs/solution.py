"""
Алгоритм поиска наибольшей общей подпоследовательности (LCS - Longest Common Subsequence).

Основная идея:
    Задача решается с помощью динамического программирования. Строится матрица dp,
    где dp[i][j] хранит длину LCS для префиксов s1[:i] и s2[:j].
    
    Рекуррентное соотношение:
    - Если s1[i-1] == s2[j-1], то dp[i][j] = 1 + dp[i-1][j-1]
    - Иначе dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    После построения матрицы выполняется обратный ход для восстановления
    самой подпоследовательности.

Оценка сложности:
    Время: O(N * M)
        - N - длина первой строки
        - M - длина второй строки
        - Требуется заполнить матрицу размером (N+1) x (M+1)
        - Восстановление подпоследовательности занимает O(N + M)
    
    Память: O(N * M)
        - Требуется матрица размером (N+1) x (M+1) для хранения DP-таблицы
        - Возможна оптимизация до O(min(N, M)), если нужна только длина LCS
"""


class LongestCommonSubsequence:
    """Класс для нахождения наибольшей общей подпоследовательности двух строк."""
    
    def __init__(self):
        """Инициализация класса LCS."""
        self.dp = None
    
    def _build_dp_table(self, s1, s2):
        """
        Строит таблицу динамического программирования для LCS.
        
        dp[i][j] содержит длину LCS для s1[:i] и s2[:j].
        
        Args:
            s1: Первая строка
            s2: Вторая строка
            
        Returns:
            Матрица dp размером (len(s1)+1) x (len(s2)+1)
        """
        m, n = len(s1), len(s2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = 1 + dp[i-1][j-1]
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        return dp
    
    def _reconstruct(self, s1, s2, dp):
        """
        Восстанавливает саму подпоследовательность по таблице dp.
        
        Идем от dp[m][n] к dp[0][0], собирая символы, которые вошли в LCS.
        
        Args:
            s1: Первая строка
            s2: Вторая строка
            dp: Таблица динамического программирования
            
        Returns:
            Строка - наибольшая общая подпоследовательность
        """
        result = []
        i, j = len(s1), len(s2)
        
        while i > 0 and j > 0:
            if s1[i-1] == s2[j-1]:
                # Символ входит в LCS
                result.append(s1[i-1])
                i -= 1
                j -= 1
            elif dp[i-1][j] > dp[i][j-1]:
                # Двигаемся вверх
                i -= 1
            else:
                # Двигаемся влево
                j -= 1
        
        # Символы собирались в обратном порядке
        return "".join(reversed(result))
    
    def find(self, s1, s2):
        """
        Находит наибольшую общую подпоследовательность двух строк.
        
        Args:
            s1: Первая строка
            s2: Вторая строка
            
        Returns:
            Строка - наибольшая общая подпоследовательность
        """
        if not s1 or not s2:
            return ""
        
        # Построение таблицы DP
        self.dp = self._build_dp_table(s1, s2)
        
        # Восстановление подпоследовательности
        return self._reconstruct(s1, s2, self.dp)
    
    def length(self, s1, s2):
        """
        Находит длину наибольшей общей подпоследовательности.
        
        Args:
            s1: Первая строка
            s2: Вторая строка
            
        Returns:
            Длина LCS
        """
        if not s1 or not s2:
            return 0
        
        self.dp = self._build_dp_table(s1, s2)
        return self.dp[len(s1)][len(s2)]
    
    def get_dp_table(self):
        """
        Возвращает последнюю вычисленную DP-таблицу.
        
        Returns:
            Матрица DP или None
        """
        return self.dp


def lcs(s1, s2):
    """
    Вспомогательная функция для нахождения LCS двух строк.
    
    Args:
        s1: Первая строка
        s2: Вторая строка
        
    Returns:
        Строка - наибольшая общая подпоследовательность
    """
    solver = LongestCommonSubsequence()
    return solver.find(s1, s2)


def lcs_length(s1, s2):
    """
    Вспомогательная функция для нахождения длины LCS двух строк.
    
    Args:
        s1: Первая строка
        s2: Вторая строка
        
    Returns:
        Длина LCS
    """
    solver = LongestCommonSubsequence()
    return solver.length(s1, s2)

